import {
  require_react
} from "./chunk-ZOIWZPCO.js";
import {
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/react-auth-kit/dist/AuthProvider.js
var React3 = __toESM(require_react());

// node_modules/react-auth-kit/dist/AuthContext.js
var React = __toESM(require_react());
var AuthContext = React.createContext(null);
var AuthContextConsumer = AuthContext.Consumer;

// node_modules/react-auth-kit/dist/_virtual/_tslib.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};

// node_modules/js-cookie/dist/js.cookie.mjs
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(name, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
  }
  function get(name) {
    if (typeof document === "undefined" || arguments.length && !name) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split("=");
      var value = parts.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);
        if (name === found) {
          break;
        }
      } catch (e) {
      }
    }
    return name ? jar[name] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(name, attributes) {
        set(
          name,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });

// node_modules/react-auth-kit/dist/TokenObject.js
var TokenObject = (
  /** @class */
  function() {
    function TokenObject2(authStorageName, authStorageType, refreshTokenName, cookieDomain, cookieSecure) {
      this.authStorageType = authStorageType;
      this.authStorageName = authStorageName;
      this.authTimeStorageName = "".concat(authStorageName, "_storage");
      this.stateStorageName = "".concat(authStorageName, "_state");
      this.refreshTokenName = refreshTokenName;
      this.cookieDomain = cookieDomain;
      this.cookieSecure = cookieSecure;
      this.authStorageTypeName = "".concat(this.authStorageName, "_type");
      this.isUsingRefreshToken = !!this.refreshTokenName;
      this.refreshTokenTimeName = this.refreshTokenName ? "".concat(this.refreshTokenName, "_time") : null;
    }
    TokenObject2.prototype.initialToken = function() {
      if (this.authStorageType === "cookie") {
        return this.initialCookieToken_();
      } else {
        return this.initialLSToken_();
      }
    };
    TokenObject2.prototype.initialCookieToken_ = function() {
      var authToken = api.get(this.authStorageName);
      var authTokenType = api.get(this.authStorageTypeName);
      var authTokenTime = api.get(this.authTimeStorageName);
      var stateCookie = api.get(this.stateStorageName);
      var refreshToken = this.isUsingRefreshToken && this.refreshTokenName != null ? api.get(this.refreshTokenName) : null;
      var refreshTokenTime = this.isUsingRefreshToken && this.refreshTokenTimeName != null ? api.get(this.refreshTokenTimeName) : null;
      return this.checkTokenExist(authToken, authTokenType, authTokenTime, stateCookie, refreshToken, refreshTokenTime);
    };
    TokenObject2.prototype.initialLSToken_ = function() {
      var authToken = localStorage.getItem(this.authStorageName);
      var authTokenType = localStorage.getItem(this.authStorageTypeName);
      var authTokenTime = localStorage.getItem(this.authTimeStorageName);
      var stateCookie = localStorage.getItem(this.stateStorageName);
      var refreshToken = this.isUsingRefreshToken && this.refreshTokenName != null ? localStorage.getItem(this.refreshTokenName) : null;
      var refreshTokenTime = this.isUsingRefreshToken && this.refreshTokenTimeName != null ? localStorage.getItem(this.refreshTokenTimeName) : null;
      return this.checkTokenExist(authToken, authTokenType, authTokenTime, stateCookie, refreshToken, refreshTokenTime);
    };
    TokenObject2.prototype.checkTokenExist = function(authToken, authTokenType, authTokenTime, stateCookie, refreshToken, refreshTokenTime) {
      if (!!authToken && !!authTokenType && !!authTokenTime && !!stateCookie) {
        var expiresAt = new Date(authTokenTime);
        try {
          var authState = JSON.parse(stateCookie);
          var obj = {
            auth: {
              token: authToken,
              type: authTokenType,
              expiresAt
            },
            userState: authState,
            isSignIn: true,
            isUsingRefreshToken: this.isUsingRefreshToken,
            refresh: void 0
          };
          if (this.isUsingRefreshToken && !!refreshToken && !!refreshTokenTime) {
            var refreshTokenExpiresAt = new Date(refreshTokenTime);
            return __assign(__assign({}, obj), { refresh: {
              token: refreshToken,
              expiresAt: refreshTokenExpiresAt
            } });
          } else {
            return __assign(__assign({}, obj), { refresh: null });
          }
        } catch (e) {
          return {
            auth: null,
            refresh: null,
            userState: null,
            isUsingRefreshToken: this.isUsingRefreshToken,
            isSignIn: false
          };
        }
      } else {
        return {
          auth: null,
          refresh: null,
          userState: null,
          isUsingRefreshToken: this.isUsingRefreshToken,
          isSignIn: false
        };
      }
    };
    TokenObject2.prototype.syncTokens = function(authState) {
      if (authState.auth) {
        if (this.isUsingRefreshToken && authState.refresh) {
          this.setToken(authState.auth.token, authState.auth.type, authState.refresh.token, authState.refresh.expiresAt, authState.auth.expiresAt, authState.userState);
        } else {
          this.setToken(authState.auth.token, authState.auth.type, null, null, authState.auth.expiresAt, authState.userState);
        }
      } else {
        this.removeToken();
      }
    };
    TokenObject2.prototype.setToken = function(authToken, authTokenType, refreshToken, refreshTokenExpiresAt, expiresAt, authState) {
      if (this.authStorageType === "cookie") {
        this.setCookieToken_(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState);
      } else {
        this.setLSToken_(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState);
      }
    };
    TokenObject2.prototype.setCookieToken_ = function(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState) {
      api.set(this.authStorageName, authToken, {
        expires: expiresAt,
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      api.set(this.authStorageTypeName, authTokenType, {
        expires: expiresAt,
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      api.set(this.authTimeStorageName, expiresAt.toISOString(), {
        expires: expiresAt,
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      if (authState) {
        api.set(this.stateStorageName, JSON.stringify(authState), {
          expires: expiresAt,
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenName && !!refreshToken) {
        api.set(this.refreshTokenName, refreshToken, {
          expires: expiresAt,
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName && !!refreshTokenExpiresAt) {
        api.set(this.refreshTokenTimeName, refreshTokenExpiresAt.toISOString(), {
          expires: expiresAt,
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
    };
    TokenObject2.prototype.setLSToken_ = function(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState) {
      localStorage.setItem(this.authStorageName, authToken);
      localStorage.setItem(this.authStorageTypeName, authTokenType);
      localStorage.setItem(this.authTimeStorageName, expiresAt.toISOString());
      if (authState) {
        localStorage.setItem(this.stateStorageName, JSON.stringify(authState));
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenName && !!refreshToken) {
        localStorage.setItem(this.refreshTokenName, refreshToken);
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName && !!refreshTokenExpiresAt) {
        localStorage.setItem(this.refreshTokenTimeName, refreshTokenExpiresAt.toISOString());
      }
    };
    TokenObject2.prototype.removeToken = function() {
      if (this.authStorageType === "cookie") {
        this.removeCookieToken_();
      } else {
        this.removeLSToken_();
      }
    };
    TokenObject2.prototype.removeCookieToken_ = function() {
      api.remove(this.authStorageName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      api.remove(this.authTimeStorageName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      api.remove(this.authStorageTypeName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      api.remove(this.stateStorageName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      if (this.isUsingRefreshToken && !!this.refreshTokenName) {
        api.remove(this.refreshTokenName, {
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName) {
        api.remove(this.refreshTokenTimeName, {
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
    };
    TokenObject2.prototype.removeLSToken_ = function() {
      localStorage.removeItem(this.authStorageName);
      localStorage.removeItem(this.authTimeStorageName);
      localStorage.removeItem(this.authStorageTypeName);
      localStorage.removeItem(this.stateStorageName);
      if (this.isUsingRefreshToken && !!this.refreshTokenName) {
        localStorage.removeItem(this.refreshTokenName);
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName) {
        localStorage.removeItem(this.refreshTokenTimeName);
      }
    };
    return TokenObject2;
  }()
);

// node_modules/react-auth-kit/dist/utils/actions.js
var ActionType;
(function(ActionType2) {
  ActionType2[ActionType2["SignIn"] = 0] = "SignIn";
  ActionType2[ActionType2["SignOut"] = 1] = "SignOut";
  ActionType2[ActionType2["RefreshToken"] = 2] = "RefreshToken";
})(ActionType || (ActionType = {}));

// node_modules/react-auth-kit/dist/utils/reducers.js
function authReducer(state, action) {
  switch (action.type) {
    case ActionType.SignIn:
      return __assign(__assign({}, state), { auth: action.payload.auth, refresh: action.payload.refresh, userState: action.payload.userState, isSignIn: true });
    case ActionType.SignOut:
      return __assign(__assign({}, state), { auth: null, refresh: null, userState: null, isSignIn: false });
    case ActionType.RefreshToken:
      if (state.isSignIn && state.auth && state.refresh) {
        return __assign(__assign({}, state), { auth: {
          token: action.payload.newAuthToken ? action.payload.newAuthToken : state.auth.token,
          type: state.auth.type,
          expiresAt: action.payload.newAuthTokenExpireIn ? new Date((/* @__PURE__ */ new Date()).getTime() + action.payload.newAuthTokenExpireIn * 60 * 1e3) : state.auth.expiresAt
        }, refresh: {
          token: action.payload.newRefreshToken ? action.payload.newRefreshToken : state.refresh.token,
          expiresAt: action.payload.newRefreshTokenExpiresIn ? new Date((/* @__PURE__ */ new Date()).getTime() + action.payload.newRefreshTokenExpiresIn * 60 * 1e3) : state.refresh.expiresAt
        }, userState: action.payload.newAuthUserState ? action.payload.newAuthUserState : state.userState });
      } else {
        return state;
      }
  }
}
function doSignIn(signInParams) {
  return {
    type: ActionType.SignIn,
    payload: signInParams
  };
}
function doRefresh(refreshTokenParam) {
  return {
    type: ActionType.RefreshToken,
    payload: refreshTokenParam
  };
}
function doSignOut() {
  return {
    type: ActionType.SignOut
  };
}

// node_modules/react-auth-kit/dist/utils/hooks.js
var React2 = __toESM(require_react());
function useInterval(callback, delay) {
  var savedCallback = React2.useRef(callback);
  var intervalRef = React2.useRef(null);
  React2.useEffect(function() {
    savedCallback.current = callback;
  }, [callback]);
  React2.useEffect(function() {
    var tick = function() {
      return savedCallback.current();
    };
    if (typeof delay === "number") {
      intervalRef.current = window.setInterval(tick, delay * 60 * 1e3);
    }
    return function() {
      if (intervalRef.current) {
        window.clearTimeout(intervalRef.current);
      }
    };
  }, [delay]);
  return intervalRef;
}

// node_modules/react-auth-kit/dist/errors.js
var AuthKitError = (
  /** @class */
  function(_super) {
    __extends(AuthKitError2, _super);
    function AuthKitError2(message) {
      return _super.call(this, message) || this;
    }
    return AuthKitError2;
  }(Error)
);

// node_modules/react-auth-kit/dist/AuthProvider.js
var AuthProvider = function(_a) {
  var children = _a.children, authType = _a.authType, authName = _a.authName, cookieDomain = _a.cookieDomain, cookieSecure = _a.cookieSecure, refresh = _a.refresh;
  if (authType === "cookie") {
    if (!cookieDomain) {
      throw new AuthKitError("authType 'cookie' requires 'cookieDomain' and 'cookieSecure' props in AuthProvider");
    }
  }
  var refreshTokenName = refresh ? "".concat(authName, "_refresh") : null;
  var tokenObject = new TokenObject(authName, authType, refreshTokenName, cookieDomain, cookieSecure);
  var _b = React3.useReducer(authReducer, tokenObject.initialToken()), authState = _b[0], dispatch = _b[1];
  if (refresh) {
    useInterval(function() {
      var _a2, _b2, _c, _d;
      refresh.refreshApiCallback({
        authToken: (_a2 = authState.auth) === null || _a2 === void 0 ? void 0 : _a2.token,
        authTokenExpireAt: (_b2 = authState.auth) === null || _b2 === void 0 ? void 0 : _b2.expiresAt,
        authUserState: authState.userState,
        refreshToken: (_c = authState.refresh) === null || _c === void 0 ? void 0 : _c.token,
        refreshTokenExpiresAt: (_d = authState.refresh) === null || _d === void 0 ? void 0 : _d.expiresAt
      }).then(function(result) {
        if (result.isSuccess) {
          dispatch(doRefresh(result));
        }
      }).catch(function() {
      });
    }, authState.isSignIn ? refresh.interval : null);
  }
  React3.useEffect(function() {
    tokenObject.syncTokens(authState);
  }, [authState]);
  return React3.createElement(AuthContext.Provider, { value: { authState, dispatch } }, children);
};

// node_modules/react-auth-kit/dist/createRefresh.js
function createRefresh(param) {
  return param;
}

// node_modules/react-auth-kit/dist/PrivateRoute.js
var React6 = __toESM(require_react());

// node_modules/react-auth-kit/node_modules/react-router-dom/dist/index.js
var React5 = __toESM(require_react());

// node_modules/react-auth-kit/node_modules/react-router-dom/node_modules/react-router/dist/index.js
var React4 = __toESM(require_react());

// node_modules/react-auth-kit/node_modules/react-router-dom/node_modules/@remix-run/router/dist/router.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
var validMutationMethodsArr = ["post", "put", "patch", "delete"];
var validMutationMethods = new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["get", ...validMutationMethodsArr];
var validRequestMethods = new Set(validRequestMethodsArr);
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");

// node_modules/react-auth-kit/node_modules/react-router-dom/node_modules/react-router/dist/index.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var DataRouterContext = React4.createContext(null);
if (true) {
  DataRouterContext.displayName = "DataRouter";
}
var DataRouterStateContext = React4.createContext(null);
if (true) {
  DataRouterStateContext.displayName = "DataRouterState";
}
var AwaitContext = React4.createContext(null);
if (true) {
  AwaitContext.displayName = "Await";
}
var NavigationContext = React4.createContext(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = React4.createContext(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = React4.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
if (true) {
  RouteContext.displayName = "Route";
}
var RouteErrorContext = React4.createContext(null);
if (true) {
  RouteErrorContext.displayName = "RouteError";
}
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = React4.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return React4.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  return React4.useContext(LocationContext).location;
}
var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function useIsomorphicLayoutEffect(cb) {
  let isStatic = React4.useContext(NavigationContext).static;
  if (!isStatic) {
    React4.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = React4.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let dataRouterContext = React4.useContext(DataRouterContext);
  let {
    basename,
    navigator
  } = React4.useContext(NavigationContext);
  let {
    matches
  } = React4.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  let activeRef = React4.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React4.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, navigateEffectWarning) : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
var OutletContext = React4.createContext(null);
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = React4.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  return React4.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (true) {
    console.error("Error handled by React Router default ErrorBoundary:", error);
    devInfo = React4.createElement(React4.Fragment, null, React4.createElement("p", null, "💿 Hey developer 👋"), React4.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", React4.createElement("code", {
      style: codeStyles
    }, "ErrorBoundary"), " or", " ", React4.createElement("code", {
      style: codeStyles
    }, "errorElement"), " prop on your route."));
  }
  return React4.createElement(React4.Fragment, null, React4.createElement("h2", null, "Unexpected Application Error!"), React4.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? React4.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
var defaultErrorElement = React4.createElement(DefaultErrorComponent, null);
var DataRouterHook;
(function(DataRouterHook3) {
  DataRouterHook3["UseBlocker"] = "useBlocker";
  DataRouterHook3["UseRevalidator"] = "useRevalidator";
  DataRouterHook3["UseNavigateStable"] = "useNavigate";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook3) {
  DataRouterStateHook3["UseBlocker"] = "useBlocker";
  DataRouterStateHook3["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook3["UseActionData"] = "useActionData";
  DataRouterStateHook3["UseRouteError"] = "useRouteError";
  DataRouterStateHook3["UseNavigation"] = "useNavigation";
  DataRouterStateHook3["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook3["UseMatches"] = "useMatches";
  DataRouterStateHook3["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook3["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook3["UseRouteId"] = "useRouteId";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = React4.useContext(DataRouterContext);
  !ctx ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = React4.useContext(DataRouterStateContext);
  !state ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = React4.useContext(RouteContext);
  !route ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? true ? invariant(false, hookName + ' can only be used on routes that contain a unique "id"') : invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook.UseRouteId);
}
function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React4.useMemo(() => matches.map((match) => {
    let {
      pathname,
      params
    } = match;
    return {
      id: match.route.id,
      pathname,
      params,
      data: loaderData[match.route.id],
      handle: match.route.handle
    };
  }), [matches, loaderData]);
}
function useRouteError() {
  var _state$errors;
  let error = React4.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);
  let activeRef = React4.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React4.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, navigateEffectWarning) : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends2({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
function Navigate(_ref4) {
  let {
    to,
    replace,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  true ? warning(!React4.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.") : void 0;
  let {
    matches
  } = React4.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(to, getPathContributingMatches(matches).map((match) => match.pathnameBase), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  React4.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace,
    state,
    relative
  }), [navigate, jsonPath, relative, replace, state]);
  return null;
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React4.useMemo(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = React4.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  true ? warning(locationContext != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (locationContext == null) {
    return null;
  }
  return React4.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, React4.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
var neverSettledPromise = new Promise(() => {
});

// node_modules/react-auth-kit/node_modules/react-router-dom/dist/index.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function getFormSubmissionInfo(target, options, basename) {
  let method;
  let action = null;
  let encType;
  let formData;
  if (isFormElement(target)) {
    let submissionTrigger = options.submissionTrigger;
    if (options.action) {
      action = options.action;
    } else {
      let attr = target.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
    }
    method = options.method || target.getAttribute("method") || defaultMethod;
    encType = options.encType || target.getAttribute("enctype") || defaultEncType;
    formData = new FormData(target);
    if (submissionTrigger && submissionTrigger.name) {
      formData.append(submissionTrigger.name, submissionTrigger.value);
    }
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    }
    if (options.action) {
      action = options.action;
    } else {
      let attr = target.getAttribute("formaction") || form.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
    }
    method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
    formData = new FormData(form);
    if (target.name) {
      formData.append(target.name, target.value);
    }
  } else if (isHtmlElement(target)) {
    throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
  } else {
    method = options.method || defaultMethod;
    action = options.action || null;
    encType = options.encType || defaultEncType;
    if (target instanceof FormData) {
      formData = target;
    } else {
      formData = new FormData();
      if (target instanceof URLSearchParams) {
        for (let [name, value] of target) {
          formData.append(name, value);
        }
      } else if (target != null) {
        for (let name of Object.keys(target)) {
          formData.append(name, target[name]);
        }
      }
    }
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData
  };
}
var _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
var _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = React5.useState({
    action: history.action,
    location: history.location
  });
  React5.useLayoutEffect(() => history.listen(setState), [history]);
  return React5.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = React5.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let {
    basename
  } = React5.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser2) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e) {
        true ? warning(false, '<Link to="' + to + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    React5.createElement("a", _extends3({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = React5.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = React5.useContext(DataRouterStateContext);
  let {
    navigator
  } = React5.useContext(NavigationContext);
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return React5.createElement(Link, _extends3({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
var Form = React5.forwardRef((props, ref) => {
  return React5.createElement(FormImpl, _extends3({}, props, {
    ref
  }));
});
if (true) {
  Form.displayName = "Form";
}
var FormImpl = React5.forwardRef((_ref6, forwardedRef) => {
  let {
    reloadDocument,
    replace,
    method = defaultMethod,
    action,
    onSubmit,
    fetcherKey,
    routeId,
    relative,
    preventScrollReset
  } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3);
  let submit = useSubmitImpl(fetcherKey, routeId);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, {
    relative
  });
  let submitHandler = (event) => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented)
      return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      method: submitMethod,
      replace,
      relative,
      preventScrollReset
    });
  };
  return React5.createElement("form", _extends3({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
if (true) {
  FormImpl.displayName = "FormImpl";
}
function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (true) {
  ScrollRestoration.displayName = "ScrollRestoration";
}
var DataRouterHook2;
(function(DataRouterHook3) {
  DataRouterHook3["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook3["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook3["UseFetcher"] = "useFetcher";
})(DataRouterHook2 || (DataRouterHook2 = {}));
var DataRouterStateHook2;
(function(DataRouterStateHook3) {
  DataRouterStateHook3["UseFetchers"] = "useFetchers";
  DataRouterStateHook3["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));
function getDataRouterConsoleError2(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext2(hookName) {
  let ctx = React5.useContext(DataRouterContext);
  !ctx ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = React5.useContext(DataRouterStateContext);
  !state ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
  return state;
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return React5.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
function useSubmitImpl(fetcherKey, fetcherRouteId) {
  let {
    router
  } = useDataRouterContext2(DataRouterHook2.UseSubmitImpl);
  let {
    basename
  } = React5.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return React5.useCallback(function(target, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    }
    let {
      action,
      method,
      encType,
      formData
    } = getFormSubmissionInfo(target, options, basename);
    let opts = {
      preventScrollReset: options.preventScrollReset,
      formData,
      formMethod: method,
      formEncType: encType
    };
    if (fetcherKey) {
      !(fetcherRouteId != null) ? true ? invariant(false, "No routeId available for useFetcher()") : invariant(false) : void 0;
      router.fetch(fetcherKey, fetcherRouteId, action, opts);
    } else {
      router.navigate(action, _extends3({}, opts, {
        replace: options.replace,
        fromRouteId: currentRouteId
      }));
    }
  }, [router, basename, fetcherKey, fetcherRouteId, currentRouteId]);
}
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = React5.useContext(NavigationContext);
  let routeContext = React5.useContext(RouteContext);
  !routeContext ? true ? invariant(false, "useFormAction must be used inside a RouteContext") : invariant(false) : void 0;
  let [match] = routeContext.matches.slice(-1);
  let path = _extends3({}, useResolvedPath(action ? action : ".", {
    relative
  }));
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    path.hash = location.hash;
    if (match.route.index) {
      let params = new URLSearchParams(path.search);
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  React5.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(React5.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches]));
  if (typeof document !== "undefined") {
    React5.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {
      }
    }, [storageKey]);
    React5.useLayoutEffect(() => {
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, getKey]);
    React5.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  React5.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}

// node_modules/react-auth-kit/dist/utils/utils.js
function isAuthenticated(auth) {
  if (auth.auth) {
    return new Date(auth.auth.expiresAt) > /* @__PURE__ */ new Date();
  }
  return false;
}

// node_modules/react-auth-kit/dist/PrivateRoute.js
var RequireAuth = function(_a) {
  var children = _a.children, loginPath = _a.loginPath;
  var context = React6.useContext(AuthContext);
  if (context === null) {
    throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  var location = useLocation();
  if (!isAuthenticated(context.authState)) {
    context.dispatch(doSignOut());
    return React6.createElement(Navigate, { to: loginPath, state: { from: location }, replace: true });
  }
  return children;
};

// node_modules/react-auth-kit/dist/hooks/useSignIn.js
var React7 = __toESM(require_react());
function useSignIn() {
  var context = React7.useContext(AuthContext);
  if (context === null) {
    throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function(signInConfig) {
    var token = signInConfig.token, tokenType = signInConfig.tokenType, authState = signInConfig.authState, expiresIn = signInConfig.expiresIn, refreshToken = signInConfig.refreshToken, refreshTokenExpireIn = signInConfig.refreshTokenExpireIn;
    var expTime = new Date((/* @__PURE__ */ new Date()).getTime() + expiresIn * 60 * 1e3);
    if (context.authState.isUsingRefreshToken) {
      if (!!refreshToken && !!refreshTokenExpireIn) {
        var refreshTokenExpireAt = new Date((/* @__PURE__ */ new Date()).getTime() + refreshTokenExpireIn * 60 * 1e3);
        context.dispatch(doSignIn({
          auth: {
            token,
            type: tokenType,
            expiresAt: expTime
          },
          userState: authState ? authState : null,
          refresh: {
            token: refreshToken,
            expiresAt: refreshTokenExpireAt
          }
        }));
        return true;
      } else {
        throw new AuthKitError('Make sure you given "refreshToken" and  "refreshTokenExpireIn" parameter');
      }
    } else {
      if (!!refreshToken && !!refreshTokenExpireIn) {
        throw new Error("The app doesn't implement 'refreshToken' feature.\nSo you have to implement refresh token feature from 'AuthProvider' before using it.");
      } else {
        context.dispatch(doSignIn({
          auth: {
            token,
            type: tokenType,
            expiresAt: expTime
          },
          userState: authState ? authState : null,
          refresh: null
        }));
        return true;
      }
    }
  };
}

// node_modules/react-auth-kit/dist/hooks/useSignOut.js
var React8 = __toESM(require_react());
function useSignOut() {
  var context = React8.useContext(AuthContext);
  if (context === null) {
    throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    try {
      if (context) {
        context.dispatch(doSignOut());
        return true;
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  };
}

// node_modules/react-auth-kit/dist/hooks/useAuthUser.js
var React9 = __toESM(require_react());
function useAuthUser() {
  var context = React9.useContext(AuthContext);
  if (context === null) {
    throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    if (isAuthenticated(context.authState)) {
      return context.authState.userState;
    } else {
      return null;
    }
  };
}

// node_modules/react-auth-kit/dist/hooks/useAuthHeader.js
var React10 = __toESM(require_react());
function useAuthHeader() {
  var c = React10.useContext(AuthContext);
  if (c === null) {
    throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    if (c.authState.auth && isAuthenticated(c.authState)) {
      return "".concat(c.authState.auth.type, " ").concat(c.authState.auth.token);
    } else {
      return "";
    }
  };
}

// node_modules/react-auth-kit/dist/hooks/useIsAuthenticated.js
var React11 = __toESM(require_react());
function useIsAuthenticated() {
  var context = React11.useContext(AuthContext);
  if (context === null) {
    throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    if (!isAuthenticated(context.authState)) {
      return false;
    } else {
      return true;
    }
  };
}

// node_modules/react-auth-kit/dist/higherOrderComponents/withSignIn.js
var React12 = __toESM(require_react());
function withSignIn(Component2) {
  return function(props) {
    return React12.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      var signIn = function(signInConfig) {
        var token = signInConfig.token, tokenType = signInConfig.tokenType, authState = signInConfig.authState, expiresIn = signInConfig.expiresIn, refreshToken = signInConfig.refreshToken, refreshTokenExpireIn = signInConfig.refreshTokenExpireIn;
        var expTime = new Date((/* @__PURE__ */ new Date()).getTime() + expiresIn * 60 * 1e3);
        if (c.authState.isUsingRefreshToken) {
          if (!!refreshToken && !!refreshTokenExpireIn) {
            var refreshTokenExpireAt = new Date((/* @__PURE__ */ new Date()).getTime() + refreshTokenExpireIn * 60 * 1e3);
            c.dispatch(doSignIn({
              auth: {
                token,
                type: tokenType,
                expiresAt: expTime
              },
              userState: authState ? authState : null,
              refresh: {
                token: refreshToken,
                expiresAt: refreshTokenExpireAt
              }
            }));
            return true;
          } else {
            throw new AuthKitError('Make sure you given "refreshToken" and "refreshTokenExpireIn" parameter');
          }
        } else {
          if (!!refreshToken && !!refreshTokenExpireIn) {
            throw new AuthKitError("The app doesn't implement 'refreshToken' feature.\n So you have to implement refresh token feature from 'AuthProvider' before using it.");
          } else {
            c.dispatch(doSignIn({
              auth: {
                token,
                type: tokenType,
                expiresAt: expTime
              },
              userState: authState ? authState : null,
              refresh: null
            }));
            return true;
          }
        }
      };
      return React12.createElement(Component2, __assign({}, props, { signIn }));
    });
  };
}

// node_modules/react-auth-kit/dist/higherOrderComponents/withSignOut.js
var React13 = __toESM(require_react());
function withSignOut(Component2) {
  return function(props) {
    return React13.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      var signOut = function() {
        try {
          if (c) {
            c.dispatch(doSignOut());
            return true;
          } else {
            return false;
          }
        } catch (e) {
          return false;
        }
      };
      return React13.createElement(Component2, __assign({}, props, { signOut }));
    });
  };
}

// node_modules/react-auth-kit/dist/higherOrderComponents/withAuthUser.js
var React14 = __toESM(require_react());
function withAuthUser(Component2) {
  return function(props) {
    return React14.createElement(AuthContextConsumer, null, function(context) {
      if (context === null) {
        throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      if (context.authState.auth && isAuthenticated(context.authState)) {
        return React14.createElement(Component2, __assign({}, props, { authState: context.authState.userState }));
      } else {
        return React14.createElement(Component2, __assign({}, props, { authState: null }));
      }
    });
  };
}

// node_modules/react-auth-kit/dist/higherOrderComponents/withAuthHeader.js
var React15 = __toESM(require_react());
function withAuthHeader(Component2) {
  return function(props) {
    return React15.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      if (c.authState.auth && isAuthenticated(c.authState)) {
        return React15.createElement(Component2, __assign({}, props, { authHeader: "".concat(c.authState.auth.type, " ").concat(c.authState.auth.token) }));
      } else {
        return React15.createElement(Component2, __assign({}, props, { authHeader: "" }));
      }
    });
  };
}

// node_modules/react-auth-kit/dist/higherOrderComponents/withIsAuthenticated.js
var React16 = __toESM(require_react());
function withIsAuthenticated(Component2) {
  return function(props) {
    return React16.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new AuthKitError("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      if (c.authState.auth && isAuthenticated(c.authState)) {
        return React16.createElement(Component2, __assign({}, props, { isAuth: true }));
      } else {
        return React16.createElement(Component2, __assign({}, props, { isAuth: false }));
      }
    });
  };
}

// node_modules/react-auth-kit/dist/index.js
AuthProvider.defaultProps = {
  cookieDomain: window.location.hostname,
  cookieSecure: window.location.protocol === "https:"
};
export {
  AuthProvider,
  RequireAuth,
  createRefresh,
  useAuthHeader,
  useAuthUser,
  useIsAuthenticated,
  useSignIn,
  useSignOut,
  withAuthHeader,
  withAuthUser,
  withIsAuthenticated,
  withSignIn,
  withSignOut
};
/*! Bundled license information:

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.6.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.11.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.11.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-auth-kit/dist/hooks/useSignIn.js:
  (**
   *@author Arkadip Bhattacharya <in2arkadipb13@gmail.com>
   *@fileoverview Sign In functionality <hook>
   *@copyright Arkadip Bhattacharya 2020
   *@license Apache-2.0
   *
   * Copyright 2020 Arkadip Bhattacharya
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *         http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=react-auth-kit.js.map
